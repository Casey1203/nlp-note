目前，我们已经讨论了如何给每个模型中的参数计算梯度。这里，我们将上面的过程一般化，一次性的更新所有的权重矩阵和偏置向量。注意到，简单的将之前讨论的模型扩展之后，可以帮助我们建立起误差的传播。

给定一个参数$W_{ij}^{(k)}$，我们指出误差梯度等于$\delta_{i}^{(k+1)}\cdot a_j^{(k)}$。提醒一下，$W^{(k)}$时将$a^{(k)}$映射到$z^{(k+1)}$的矩阵。我们可以建立起整个矩阵$W^{(k)}$的误差梯度，即
$$
\nabla_{W^{(k)}}=\left[ \begin{array}{ccc}{\delta_{1}^{(k+1)} a_{1}^{(k)}} & {\delta_{1}^{(k+1)} a_{2}^{(k)}} & {\dots} \\ {\delta_{2}^{(k+1)} a_{1}^{(k)}} & {\delta_{2}^{(k+1)} a_{2}^{(k)}} & {\dots} \\ {\vdots} & {\vdots} & {\ddots}\end{array}\right]=\delta^{(k+1)} a^{(k) T}
$$
因此，我们可以用传递到矩阵$W^{(k)}$的误差向量$\delta^{(k+1)}$和给矩阵输入的激活向量$a^{(k)}$，通过这两个向量的外积(outer product)，我们可以写出整个矩阵的误差梯度。

现在，我们看看如何计算误差向量$\delta^{(k)}$。利用图8，我们知道了误差向量$\delta^{(k)}_j=f'(z_j^{(k)})\sum_{i} \delta_{i}^{(k+1)} W_{i j}^{(k)}$。我们可以将其写成矩阵的形式。
$$
\delta^{(k)}=f^{\prime}\left(z^{(k)}\right) \circ\left(W^{(k) T} \delta^{(k+1)}\right)
$$
上面的形式中，$\circ$表示元素与元素相乘（element-wise product）$\left(\circ : \mathbb{R}^{N} \times \mathbb{R}^{N} \rightarrow \mathbb{R}^{N}\right)$。

**计算效率**：按元素更新，或按向量更新，我们必须意识到，在matlab或者numpy中，用向量化的方式开发，要快很多。因此，我们实践中要用向量化的方式开发。更进一步，我们在后向传播中，应该减少多余的计算。因此，我们必须保证，当利用$\delta^{(k+1)}$来更新$W^{(k)}$时，我们要保存$\delta^{(k+1)}$，以便之后计算$\delta^{(k)}$，并且要重复$(k-1)\ldots (1)$。这样一个递归的过程，使得后向传播非常快。